.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "NE_SSL_SET_VERIFY" 3 "9 August 2002" "neon 0.22.0" "neon API reference"
.SH NAME
ne_ssl_set_verify \- register an SSL certificate verification callback
.SH "SYNOPSIS"
.ad l
.hy 0

#include <ne_session.h>
.sp
.HP 34
typedef\ int\ (*\fBne_ssl_verify_fn\fR)\ (void\ *\fIuserdata\fR, int\ \fIfailures\fR, const\ ne_ssl_certificate\ *\fIcert\fR);
.HP 24
void\ \fBne_ssl_set_verify\fR\ (ne_session\ *\fIsession\fR, ne_ssl_verify_fn\ \fIverify_fn\fR, void\ *\fIuserdata\fR);
.ad
.hy

.SH "DESCRIPTION"

.PP
To enable manual SSL certificate verification, a callback can be registered using \fBne_ssl_set_verify\fR. If such a callback is not registered, when a connection is established to an SSL server which does not present a certificate signed by a trusted CA (see \fBne_ssl_load_ca\fR(3)), or if the certificate presented is invalid in some way, the connection will fail.

.PP
When the callback is invoked, the \fIfailures\fR parameter gives a bitmask indicating in what way the automatic certificate verification failed. The value is equal to the bit-wise OR of one or more of the following constants (and is guaranteed to be non-zero):

.TP
\fINE_SSL_NOTYETVALID\fR
The certificate is not yet valid.

.TP
\fINE_SSL_EXPIRED\fR
The certificate has expired.

.TP
\fINE_SSL_CNMISMATCH\fR
The hostname used for the session does not match the hostname to which the certificate was issued: this could mean that the connection has been intercepted.

.TP
\fINE_SSL_UNKNOWNCA\fR
The Certificate Authority which signed the certificate is not trusted.

.PP
The \fIcert\fR parameter passed to the callback describes the certificate which was presented by the server, see \fBne_ssl_certificate\fR(3) for more details. The certificate object given is only valid until the callback returns.

.SH "RETURN VALUE"

.PP
The verification callback must return zero to indicate that the certificate should be trusted; and non-zero otherwise (in which case, the connection will fail).

.SH "EXAMPLES"

.PP
Manual certificate verification:

.nf

static int
my_verify(void *userdata, int failures, const ne_ssl_certificate *cert)
{
   /* leak the return values of ne_ssl_readable_dname for simplicity! */
   printf("Issuer: %s\\n", ne_ssl_readable_dname(cert->issuer);
   printf("Subject: %s\\n", ne_ssl_readable_dname(cert->subject);
   if (failures & NE_SSL_CNMISMATCH) {
      printf("Server certificate was issued to `%s'; "
             "connection may have been intercepted!\\n",
             cert->subject->commonName);
   }
   if (failures & NE_SSL_EXPIRED) {
      printf("Server certificate expired on %s!", cert->until);
   }
   /* ... check for other failures ... */
   if (prompt_user())
      return 1; /* fail verification */
   else
      return 0; /* trust certificate */
}

int
main(...)
{
    ne_session *sess = ne_session_create("https", "some.host.name", 443);
    ne_ssl_set_verify(sess, my_verify, NULL);
    ...
}
.fi

.SH "SEE ALSO"

.PP
\fBne_ssl_certificate\fR(3), \fBne_ssl_load_ca\fR(3), \fBne_ssl_dname\fR(3), \fBne_ssl_readable_dname\fR(3)

.SH AUTHOR
Joe Orton  <neon@webdav.org>.
