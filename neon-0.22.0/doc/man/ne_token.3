.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "NE_TOKEN" 3 "9 August 2002" "neon 0.22.0" "neon API reference"
.SH NAME
ne_token, ne_qtoken \- string tokenizers
.SH "SYNOPSIS"
.ad l
.hy 0

#include <ne_string.h>
.sp
.HP 16
char\ *\fBne_token\fR\ (char\ **\fIstr\fR, char\ \fIsep\fR);
.HP 17
char\ *\fBne_qtoken\fR\ (char\ **\fIstr\fR, char\ \fIsep\fR, const\ char\ *\fIquotes\fR);
.ad
.hy

.SH "DESCRIPTION"

.PP
\fBne_token\fR and \fBne_qtoken\fR tokenize the string at the location stored in the pointer \fIstr\fR. Each time the function is called, it returns the next token, and modifies the \fIstr\fR pointer to point to the remainer of the string, or NULL if there are no more tokens in the string. A token is delimited by the separator character \fIsep\fR; if \fBne_qtoken\fR is used any quoted segments of the string are skipped when searching for a separator. A quoted segment is enclosed in a pair of one of the characters given in the \fIquotes\fR string.

.PP
The string being tokenized is modified each time the tokenizing function is called; replacing the next separator character with a NUL terminator.

.SH "EXAMPLES"

.PP
The following function prints out each token in a comma-separated string \fIlist\fR, which is modified in-place:

.nf
static void splitter(char *list)
{
  do {
    printf("Token: %s\\n", ne_token(&list, ','));
  while (list);
}
.fi

.SH AUTHOR
Joe Orton  <neon@webdav.org>.
