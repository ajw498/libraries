.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "NE_BUFFER_DESTROY" 3 "9 August 2002" "neon 0.22.0" "neon API reference"
.SH NAME
ne_buffer_destroy, ne_buffer_finish \- destroy a buffer object
.SH "SYNOPSIS"
.ad l
.hy 0

#include <ne_string.h>
.sp
.HP 24
void\ \fBne_buffer_destroy\fR\ (ne_buffer\ *\fIbuf\fR);
.HP 24
char\ *\fBne_buffer_finish\fR\ (ne_buffer\ *\fIbuf\fR);
.ad
.hy

.SH "DESCRIPTION"

.PP
\fBne_buffer_destroy\fR frees all memory associated with the buffer. \fBne_buffer_finish\fR frees the buffer structure, but not the actual string stored in the buffer, which is returned and must be \fBfree\fR()d by the caller.

.PP
Any use of the buffer object after calling either of these functions gives undefined behaviour.

.SH "RETURN VALUE"

.PP
\fBne_buffer_finish\fR returns the \fBmalloc\fR-allocated string stored in the buffer.

.SH "EXAMPLES"

.PP
An example use of \fBne_buffer_finish\fR; the \fBduplicate\fR function returns a string made up of \fIn\fR copies of \fIstr\fR:

.nf
static char *duplicate(int n, const char *str)
{
  ne_buffer *buf = ne_buffer_create();
  while (n--) {
    ne_buffer_zappend(buf, str);
  }
  return ne_buffer_finish(buf);
}
.fi

.SH "SEE ALSO"

.PP
\fBne_buffer\fR(3), \fBne_buffer_create\fR(3), \fBne_buffer_zappend\fR(3)

.SH AUTHOR
Joe Orton  <neon@webdav.org>.
